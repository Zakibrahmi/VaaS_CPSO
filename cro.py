# -*- coding: utf-8 -*-
"""VaaS-CRO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v2Bx5crEUrCkRv29VNVH8WQD8tPOruqC
"""
import json
from collections import deque

import random
#import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from network_smart.local_paths import *
import pandas as pd
from network_smart.region import Region
from composition.composite_vaas import composite_vaas


# generate regions
def generate_regions(num_regions=20):
    regions = []
    for i in range(num_regions):
        region_id = f"R{i+1}"
        region = {
            "ID": region_id,
            "path": round(random.uniform(15, 25), 2),
            "type": random.choice(region_types),
            "transport_mode": random.sample(vaas_types, random.randint(1, 3)),
            "neighborhood": random.sample([f"R{j+1}" for j in range(num_regions) if j != i], random.randint(2, 4))
        }
        regions.append(region)
    return regions


def display_regions_neighborhood(file_path, title="Regions inter-connections", figsize=(7, 7)):
    # Load Regions data from JSON file
    with open(file_path, "r") as f:
        regions_data = json.load(f)

    # Extract region IDs and initialize matrix
    region_ids = [region["ID"] for region in regions_data]
    num_regions = len(region_ids)
    matrix = np.zeros((num_regions, num_regions), dtype=int)

    # Create a mapping from region ID to matrix index
    region_index = {region_id: idx for idx, region_id in enumerate(region_ids)}

    # Fill the matrix based on neighborhood connections
    for region in regions_data:
        row_idx = region_index[region["ID"]]
        for neighbor in region["neighborhood"]:
            if neighbor in region_index:
                col_idx = region_index[neighbor]
                matrix[row_idx, col_idx] = 1
    """"
    # Display the matrix using a heatmap
    plt.figure(figsize=figsize)
    sns.heatmap(matrix, annot=True, cmap="YlGnBu", cbar=False, fmt="d",
                linewidths=.5, linecolor='black',
                xticklabels=region_ids, yticklabels=region_ids)
    plt.title(title)
    plt.xlabel("Regions")
    plt.ylabel("Regions")
    plt.show()
    """

# Define region types and VaaS types
region_types = [
    "residential suburb", "green zone", "business park", "industrial zone", "educational campus",
    "recreational area", "retirement community", "rural town", "urban fringe", "health retreat",
    "commercial center", "technology hub", "agricultural zone", "coastal area", "historical district"
]
"""
regions = generate_regions()

# Save data to json files
with open("Regions.json", "w") as f:
    json.dump(regions, f, indent=4)

print("Files generated: Regions.json")
"""
#display_regions_neighborhood("Regions.json")


# generate VaaS services
def generate_vaas(num_vaas=50):
    vaas_services = []
    for i in range(num_vaas):
        vaas_id = f"VaaS{i+1}"
        vaas = {
            "ID": vaas_id,
            "cost": round(random.uniform(2.5, 6.0), 2),
            "max_speed": random.randint(40, 120),
            "type": random.choice(vaas_types),
            "rating": round(random.uniform(1, 5), 2),
            "availability": round(random.uniform(0, 1), 2),
            "coverage": random.sample([f"R{j+1}" for j in range(20)], random.randint(2, 6))
        }
        vaas_services.append(vaas)
    return vaas_services

def display_vaas_coverage(file_path, title="VaaS coverage matrix", figsize=(8, 12)):
    # Load VaaS data from JSON file
    with open(file_path, "r") as f:
        vaas_data = json.load(f)

    # Extract VaaS IDs and regions IDs
    vaas_ids = [vaas["ID"] for vaas in vaas_data]
    all_regions = sorted({region for vaas in vaas_data for region in vaas["coverage"]})

    # Initialize an empty coverage matrix
    num_vaas = len(vaas_ids)
    num_regions = len(all_regions)
    matrix = np.zeros((num_vaas, num_regions), dtype=int)

    # Create a mapping from VaaS ID and region ID to matrix indices
    vaas_index = {vaas_id: idx for idx, vaas_id in enumerate(vaas_ids)}
    region_index = {region_id: idx for idx, region_id in enumerate(all_regions)}

    # Fill the matrix based on VaaS coverage
    for vaas in vaas_data:
        row_idx = vaas_index[vaas["ID"]]
        for region in vaas["coverage"]:
            if region in region_index:
                col_idx = region_index[region]
                matrix[row_idx, col_idx] = 1
    """
    # Display the matrix using a heatmap
    plt.figure(figsize=figsize)
    sns.heatmap(matrix, annot=True, cmap="YlGnBu", cbar=False, fmt="d",
                linewidths=.5, linecolor='black',
                xticklabels=all_regions, yticklabels=vaas_ids)
    plt.title(title)
    plt.xlabel("Regions")
    plt.ylabel("VaaS IDs")
    plt.show()
    """

# Generate VaaS services and save to VaaS.json

vaas_types = [
    "smart bus", "autonomous car", "shared bicycle", "smart scooter", "electric shuttle",
    "on-demand minibus", "drone taxi", "electric car", "hydrogen bus", "automated tram"
]

#vaas_services = generate_vaas()
#with open("VaaS.json", "w") as f:
 #   json.dump(vaas_services, f, indent=4)

#print("Files generated: VaaS.json")

#display_vaas_coverage("VaaS.json")

"""# **Step 1: Regions search**
This step aims at finding the best sequence $R_{st}$ of SUN regions from source to target regions $r_s,r_t$.
"""


def find_best_sequence(file_path, r_s, r_t):
    """Find the best sequence of regions from source r_s to target r_t."""

    # Load regions data
    with open(file_path, "r") as f:
        regions_data = json.load(f)

    # Create adjacency list for regions
    adjacency_list = {}
    for region in regions_data:
        adjacency_list[region["ID"]] = region["neighborhood"]

    # Initialize BFS
    queue = deque([(r_s, [r_s])])  # Store tuples of (current_region, path)
    visited = set()
    while queue:
        current_region, path = queue.popleft()
        # If we reach the target region, return the path
        if current_region == r_t:
            return path

        # Mark the current region as visited
        if current_region not in visited:
            visited.add(current_region)

            # Enqueue all unvisited neighbors
            for neighbor in adjacency_list[current_region]:
                if neighbor not in visited:
                    queue.append((neighbor, path + [neighbor]))

    # If we exhaust the queue without finding the target
    return None

"""# **Step 2: CVaaS generation**
This step aims at generating all the possible VaaS combinations that cover the traversed regions from $r_s$ to $r_t$. These combinations will be inputted to CRO as the initial population.
"""

def load_vas_data(file_path):
    """Load VaaS data from a JSON file."""
    with open(file_path, "r") as f:
        return json.load(f)

def sort_vaas_by_coverage(VaaS_data, r_s):
    """Extract and sort VaaS services by coverage capacity in decreasing order."""
    VaaS_s = [vaas for vaas in VaaS_data if r_s in vaas.covered_regions]
    sorted_VaaS = sorted(VaaS_s, key=lambda x: len(x.covered_regions), reverse=True)

    return sorted_VaaS

def can_cover_all_regions(R_st, VaaS_data):
    """Check if each region in R_st can be covered by at least one VaaS."""
    for region in R_st:
        if not any(region in vaas.covered_regions for vaas in VaaS_data):
            return False  # If any region is uncovered, return False
    return True

def find_vaas_combinations(R_st, VaaS_data):
    """Generate combinations of VaaS services that sequentially cover consecutive regions in R_st."""

    # First, check if every region in R_st can be covered by at least one VaaS
    if not can_cover_all_regions(R_st, VaaS_data):
        print("No feasible combination: some regions in R_st cannot be covered by any VaaS.")
        return []  # No possible combinations if any region is uncovered

    r_s = R_st[0]
    VaaS_s = sort_vaas_by_coverage(VaaS_data, r_s)
    Candidates = set()

    def cover_consecutive_regions(current_combination, uncovered_regions):
        """Recursive function to generate sequential VaaS combinations covering consecutive regions in R_st."""
        if not uncovered_regions:
            # Convert each (vaas_id, regions_covered) pair to a tuple with regions_covered also as tuple
            hashed_combination = tuple((vaas_id, tuple(regions)) for vaas_id, regions in current_combination)
            Candidates.add(hashed_combination)
            return

        for vaas in VaaS_data:
            consecutive_regions = []
            for region in uncovered_regions:
                if region in vaas.covered_regions:
                    consecutive_regions.append(region)
                else:
                    # Stop if we reach a region that isn't covered consecutively
                    break

            if consecutive_regions:
                # Extend the current combination with the VaaS covering consecutive regions
                new_combination = current_combination + [(vaas.uid, consecutive_regions)]
                # Remove the consecutively covered regions from the list of uncovered regions
                new_uncovered = uncovered_regions[len(consecutive_regions):]
                # Recurse with the updated combination and uncovered regions
                cover_consecutive_regions(new_combination, new_uncovered)

    # Initialize recursive coverage with the sorted VaaS services
    for vaas in VaaS_s:
        consecutive_regions = []
        for region in R_st:
            if region in vaas.covered_regions:
                consecutive_regions.append(region)
            else:
                break

        if consecutive_regions:
            initial_combination = [(vaas.uid, consecutive_regions)]
            uncovered_regions = R_st[len(consecutive_regions):]
            cover_consecutive_regions(initial_combination, uncovered_regions)

    # Return list of Candidates or empty list if no combinations are found
    return list(Candidates) if Candidates else []

def print_cvaas(combinations):
    """Display each VaaS combination along with regions covered by each VaaS."""
    for idx, combination in enumerate(combinations, start=1):
        solution_str = f"Solution {idx}: "
        vaas_coverage_map = [f"{vaas_id} ({', '.join(regions)})" for vaas_id, regions in combination]
        solution_str += ", ".join(vaas_coverage_map)
        print(solution_str)

def print_high_coverage_cvaas(combinations):
    """Display each VaaS combination in order of fewer services, with regions covered by each VaaS."""
    # Sort combinations by the number of VaaS services in each combination (ascending order)
    sorted_combinations = sorted(combinations, key=len)

    for idx, combination in enumerate(sorted_combinations, start=1):
        solution_str = f"Solution {idx}: "
        vaas_coverage_map = [f"{vaas_id} ({', '.join(regions)})" for vaas_id, regions in combination]
        solution_str += ", ".join(vaas_coverage_map)
        print(solution_str)

def find_min_vaas_combination(combinations):
    """Return the combination with the fewest VaaS services, or None if no combinations exist."""
    sorted_combinations = sorted(combinations, key=len)
    return sorted_combinations[0] if sorted_combinations else None

# Example usage
#vaas_path = "VaaS.json"  # Replace with your VaaS.json path
#VaaS_data = load_vas_data(vaas_path)

#R_st = ['R1', 'R2', 'R3','R4']  # Example sequence of traversed regions
#candidates = find_vaas_combinations(R_st, VaaS_data)
#print(candidates)
# Print the candidate combinations with regions covered by each VaaS
#print_cvaas(candidates)

#print("\nVaaS combinations sorted by coverage capacity:")
#print_high_coverage_cvaas(candidates)

#print("\nMinimum VaaS combination:")
#print(find_min_vaas_combination(candidates))

"""# **Step 3: Optimal VaaS selection based on CRO**
This step uses CRO to optimize the selection of best VaaS combination. The population of molecules (candidate VaaS combinations) will undergo a number of reactions (*OnWall, Decomposition, InterMolecule, Synthesis*) while evaluating their fitness. In CRO (Chemical Reaction Optimization), a population is a set of candidate solutions (candidate VaaS combinations in our case), and a molecule is a candidate solution (VaaS combination in our case). Each molecule contains a set of atoms. In our case, an atom represents a VaaS service, and the set of atoms (molecule) represent the set of VaaS services that will traverse the regions in $R_{st}$.
"""

# Load VaaS and Regions data from JSON files
def load_data(file_path):
    with open(file_path, "r") as f:
        return json.load(f)

# CRO operations
def on_wall_molecule(molecule, R_st, VaaS_data):
    """Randomly modify one VaaS in the molecule while ensuring coverage of R_st."""
    new_molecule = list(molecule[:])

    vaas_id = random.choice(new_molecule)[0]
    for vaas in VaaS_data:
        if vaas.uid != vaas_id and is_valid_combination(new_molecule + [(vaas.uid, vaas.covered_regions)], R_st):

            # Check if the item exists in the list before removing it
            vid = (vaas_id, [r for r in vaas.covered_regions if r in R_st])

            if vid in new_molecule:
                new_molecule.remove(vid)

            new_molecule.append((vaas.uid, [r for r in vaas.covered_regions if r in R_st]))
            break
    return new_molecule

def decomposition(molecule):
    """Split molecule into two parts."""
    split_point = len(molecule) // 2
    return molecule[:split_point], molecule[split_point:]

def inter_molecule(molecule1, molecule2, R_st):
    """Combine two molecules and remove duplicates while ensuring coverage of R_st."""
    combined = tuple(molecule1) + tuple([vaas for vaas in molecule2 if vaas[0] not in [v[0] for v in molecule1]])
    if is_valid_combination(combined, R_st):
        return combined
    return molecule1

def synthesis(molecule1, molecule2, R_st):
    """Create a new molecule by randomly selecting VaaS services from two molecules."""
    new_molecule = []
    for vaas1, vaas2 in zip(molecule1, molecule2):
        selected = random.choice([vaas1, vaas2])
        if selected not in new_molecule:
            new_molecule.append(selected)
    return new_molecule if is_valid_combination(new_molecule, R_st) else molecule1

def is_valid_combination(combination, R_st):
    """Check if a combination of VaaS services covers all regions in R_st in sequence."""
    covered_regions = list(r for vaas in combination for r in vaas[1])
    return all(region in covered_regions for region in R_st) and len(combination) <= len(R_st) and len(covered_regions) == len(R_st) and covered_regions == R_st

# Fitness calculation
def calculate_fitness(solution, problem):

    #p = composite_vaas(path_regions=R_st, weights=weights,query=user_query, set_vaas=vaas_dict, objective_function=functionF)
    """
    total_cost, total_trip_time, total_availability, total_rating, v = 0, 0, 0, 0, len(candidate)
    for vaas_id, regions in candidate:
        vaas = vaas_dict.get(vaas_id)
        for region_id in R_st:
            region = regions_dict.get(region_id)
            if region and region_id in regions:
                path_distance = region["path"]
                trip_time = path_distance / vaas["max_speed"]
                region_cost = vaas["cost"] * path_distance
                total_trip_time += trip_time
                total_cost += region_cost
        total_availability += vaas["availability"]
        total_rating += vaas["rating"]

    avg_rating = total_rating / v if v > 0 else 0
    avg_availability = total_availability / v if v > 0 else 0
    score = (1 / v) * (w1 * total_trip_time + w2 * total_cost + w3 * avg_rating + w4 * avg_availability) if v != 0 else 0
    return score, total_cost, total_trip_time, total_rating
    """
    return problem.obj_func(solution)
# CRO optimization
def cro_optimization(candidates, R_st, vaas_dict, problem, k=3, iterations=100):
    best_molecule = None
    best_score = float("inf")
    population = list(candidates)
    all_results = []
    i =0
    
    for _ in range(iterations):
        molecule = random.choice(population)
        # Convert the solution to an array  to be used to calcuate the fitness
        array_size = max(index[0] for _, index in molecule) + 1
        moleculetmp = [None] * array_size
        # Populate the array
        for value, index in molecule:
            if isinstance(index, tuple):
                index = index[0]
            moleculetmp[index] = value
        
        # Choose an operation randomly
        operation = random.choice(["OnWall", "Decomposition", "InterMolecule", "Synthesis"])
        if operation == "OnWall":
            new_molecule = on_wall_molecule(molecule, R_st, list(vaas_dict.values()))
        elif operation == "Decomposition":
            part1, part2 = decomposition(molecule)
            population.extend([part1, part2])
            continue
        elif operation == "InterMolecule":
            another_molecule = random.choice([m for m in population if m != molecule])
            new_molecule = inter_molecule(molecule, another_molecule, R_st)
        elif operation == "Synthesis":
            another_molecule = random.choice([m for m in population if m != molecule])
            new_molecule = synthesis(molecule, another_molecule, R_st)

        # Check if the new molecule is a valid combination
        if is_valid_combination(new_molecule, R_st):
          # Evaluate fitness of the new molecule
          score = calculate_fitness(moleculetmp, problem)

          # Update the best molecule if the new one has a better score
          if score < best_score:
              best_molecule = new_molecule
              best_score = score
          # Add new molecule to population
          population.append(new_molecule)
          # Keep track of all results
          all_results.append((new_molecule, score))
        

    # Sort all results by fitness score
    all_results.sort(key=lambda x: x[1])

    # Return the top-k best solutions
    top_k = all_results[:k]
    
    return top_k
    
"""# **Tests on the score of CRO-based VaaS Composition**"""
def run_cro(regions, vaas_set, problem):

    # Load data
    #VaaS_data = load_data("VaaS.json")
    #Regions_data = load_data("Regions.json")
    # Convert data to dictionaries for quick lookup
    vaas_dict = {vaas.uid: vaas for vaas in vaas_set}        
    #r_s = input("Enter the source region (e.g., 'R1'): ").upper()
    #r_t = input("Enter the target region (e.g., 'R5'): ").upper()
    #R_st = find_best_sequence("Regions.json", r_s.upper(), r_t.upper())    
    
    R_st=[r for r in regions]   
    
    #total_distance = sum(region["path"] for region in regions if region["ID"] in R_st)
    # Load or generate candidate VaaS compositions
    candidates = find_vaas_combinations(R_st, vaas_set)
    
    # Specify the top-k you want to retrieve
    # Run CRO optimization and get the top-k solutions
    top_k_combinations = cro_optimization(
        candidates=candidates, R_st= R_st, vaas_dict=vaas_dict, problem=problem, k=3,
        iterations=50
    )
    
    # Print the top-k best combinations with additional metrics
    return top_k_combinations[0][1]
   
    
    #return 
"""# **Tests on minumal VaaS combinations.**"""


def load_vas_data(file_path):
    """Load VaaS data from a JSON file."""
    with open(file_path, "r") as f:
        return json.load(f)

#Test with different trips

R_st_values = [
     ['R1', 'R2'],
      ['R7', 'R6', 'R9'],
    ['R1', 'R2', 'R6', 'R8', 'R11'],
    ['R3', 'R5', 'R7', 'R9'],
    ['R1', 'R4', 'R8', 'R10', 'R12'],
    ['R2', 'R3', 'R5', 'R8', 'R11'],
     ['R2', 'R4', 'R6', 'R8', 'R10'],
     ['R2', 'R4', 'R6', 'R8', 'R10','R12'],
     ['R2', 'R4', 'R6', 'R8', 'R10','R14'],
    ['R1', 'R2', 'R3', 'R4', 'R5']
]

def test_find_vaas_combinations(R_st_values, VaaS_data):

    for idx, R_st in enumerate(R_st_values, start=1):

        candidates = find_vaas_combinations(R_st, VaaS_data)
        min_combination = find_min_vaas_combination(candidates)
        print("\nMinimum VaaS combination for R_st ", R_st, ":", min_combination)

# Example usage
#vaas_path = "VaaS.json"
#VaaS_data = load_vas_data(vaas_path)
#test_find_vaas_combinations(R_st_values, VaaS_data)
""""
regions = Region.create_regions(number_region=2, min_edges=2, min_nodes=20, max_edges=15, max_nodes=30)
user_query ={'source': 1,'destination':30, 'QoS':{'cost': 8, 'speed':100, 'availability':0.98, 'reputation': 0.8, 'place':2, 'rating':8}}
vaas_dataset = pd.read_csv("./dataset/vaas.csv")["name_dataset"]

from network_smart.vass import VaaS
from mealpy.utils.space import FloatVar, IntegerVar

c = local_paths(regions)
regions_path = c.run(user_query["source"], user_query["destination"])      
# Extract  regions to be our path:
traversed_region = regions_path['regions']
weights = [0.25, 0.25, 0.25, 0.25]
for d in vaas_dataset:
    # proceed each dataset 
    vaas = pd.read_csv(f"./dataset/vaas/{d}.csv")
    vaas_set =[]
    for  index, v in vaas.iterrows():
        vs = VaaS(data=v)
        vaas_set.append(vs)
    bounds = IntegerVar(lb=[0, ]*len(traversed_region), ub=[len(vaas_set)-1, ]*len(traversed_region), name="vaas_var")
    problem = composite_vaas(bounds=bounds,path_regions=regions_path, weights=weights,query= user_query, set_vaas= vaas_set, objective_function="all")

    print(run_cro(regions=traversed_region,vaas_set=vaas_set, problem=problem))
"""