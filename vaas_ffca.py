# -*- coding: utf-8 -*-
"""VaaS_FFCA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UPEDA-dDCu-_b9iU5yvesd-lp0pF_A7j

# **Personalized Service Recommendation in Smart Mobility Networks**
The following are the major steps of the VaaS composition process:

1.   **Region-based path search:** first, a set of partial (local) paths are determined for the regions that connect the user's requested source and destination. These regions are first extracted from the coverage lattice. The aggregated local paths should satisfy the trip constraints, mainly the time and the cost, and will be used in the generation of candidate VaaS combinations (CVaaS).
2.   **CVaaS composition:** In this step, the generation of VaaS combinations is achieved by exploring the VaaSs' fuzzy lattice to select the high-capacity transport services that cover the regions constituting the whole trip.
3.   **CVaaS evaluation:** In this step, a penalty-based score is computed for each composite VaaS, by taking into consideration user constraints, VaaS features, and coverage capacities. Finally, the VaaS combination with the highest score is returned to the user.
"""
import random
import json
import os
from collections import defaultdict
import numpy as np
import itertools
from itertools import product
from bisect import bisect_left
from network_smart.region import Region
import pandas as pd
from network_smart.vass import VaaS
from composition.CP_PSO_VaaS import PSO_VaaS
from network_smart.network_region import *
from network_smart.local_paths import *


"""# **Data preparation:**
Feeding the formal contexts with data from json files. The formal context are then used to build the coverage, VaaS, and connectivity lattices.
"""
# **Lattice construction from extracted formal contexts**"""

def load_json_file(filename):
    """Load data from a JSON file."""
    with open(filename, "r") as file:
        return json.load(file)

def extract_formal_concepts(data):
    """Generate formal concepts by finding objects with common attributes."""
    objects = list(data.keys())
    attributes = list(next(iter(data.values())).keys())

    # Find formal concepts by grouping objects based on common attributes
    concepts = []
    for attr_comb in range(1, 2 ** len(attributes)):
        selected_attrs = [attributes[i] for i in range(len(attributes)) if (attr_comb >> i) & 1]
        extent = [obj for obj in objects if all(data[obj][attr] == 1 for attr in selected_attrs)]
        if extent:
            concepts.append({"Extent": extent, "Intent": selected_attrs})
    concepts.sort(key=lambda concept: len(concept["Intent"]), reverse=True)
    return concepts

def print_formal_concepts(concepts, name):
    print(f"\n{name} Lattice has {len(concepts)} formal concepts.")
    for i, concept in enumerate(concepts, start=1):
        print(f"Concept {i}: Extent={concept['Extent']}, Intent={concept['Intent']}")

def reduce_lattice(lattice):
    reduced_lattice = []

    # Helper function to check if a concept is redundant
    def is_redundant(concept, other):
        # Check if concept is redundant with respect to another concept
        extent_redundant = set(concept["Extent"]) <= set(other["Extent"])
        intent_redundant = set(concept["Intent"]) <= set(other["Intent"])
        return extent_redundant and intent_redundant

    for concept in lattice:
        # Check against all concepts in the reduced lattice for redundancy
        if any(is_redundant(concept, other) for other in reduced_lattice):
            continue
        # Remove redundant concepts from reduced_lattice before adding the current one
        reduced_lattice = [other for other in reduced_lattice if not is_redundant(other, concept)]
        # Add the current concept to the reduced lattice
        reduced_lattice.append(concept)

    return reduced_lattice


"""# **VaaS Recommendation Process**"""

def load_json_file(filename):
    """Load data from a JSON file."""
    with open(filename, "r") as file:
        return json.load(file)

def find_paths(connectivity, current, target, visited, path, all_paths):
    """Recursively finds paths from the current region to the target region."""
    # Add the current region to the path and mark it as visited
    path.append(current)
    visited.add(current)

    # If the current region is the target, save the path
    if current == target:
        all_paths.append(list(path))
    else:
        # Recursively explore all connected (neighbor) regions
        for neighbor, is_connected in connectivity[current].items():
            if is_connected == 1 and neighbor not in visited:
                find_paths(connectivity, neighbor, target, visited, path, all_paths)

    # Backtrack: remove the current region from path and mark it as unvisited
    path.pop()
    visited.remove(current)

def find_shortest_path(connectivity, r_s, r_t):
    """Finds the shortest path from region r_s to region r_t based on connectivity."""
    # Check if r_s and r_t are directly connected
    if connectivity[r_s][r_t] == 1:
        return [r_s, r_t]

    # If not directly connected, find all paths using DFS
    all_paths = []
    find_paths(connectivity, r_s, r_t, visited=set(), path=[], all_paths=all_paths)

    # Return the path with the minimum number of intermediate regions
    shortest_path = min(all_paths, key=len) if all_paths else None
    return shortest_path


def filter_by_type(Candidates, v_t):
    with open("VaaS.json", "r") as file:
        vaas_data = json.load(file)

    # Create a dictionary to map VaaS IDs to their types
    vaas_type_map = {vaas["ID"]: vaas["type"] for vaas in vaas_data}

    # Filter the Candidates set
    filtered_candidates = set()
    for combination in Candidates:
        # Check if all VaaS services in the combination match the required type v_t
        if all(vaas_type_map.get(vaas_id) in v_t for vaas_id in combination):
            filtered_candidates.add(combination)

    return filtered_candidates

def find_candidates(R_st, L_cov):
    """Find candidate transportation services based on traversed regions R_st and coverage lattice L_cov."""
    # Initialize the set for candidate solutions
    Candidates = set()

    # Case 1: If r_s equals r_t (single region in R_st)
    
    if len(R_st) == 1:        
        Candidates = set()
        # Iterate through each concept in largest_extent_concepts
        for cpt in L_cov:
            # Check if the length of the Extent is equal to max_extent_size
            if len(cpt["Extent"]) == 1 and set(R_st).issubset(cpt["Intent"]):
                # Iterate through each item in the Extent and add it as a tuple to Candidates
                for item in cpt["Extent"]:
                    Candidates.add((item,))  # Add item as a tuple

    # Case 2: r_s and r_t are different and directly connected (R_st has exactly two regions)
    elif len(R_st) == 2:
        r_s, r_t = R_st
        # Find the formal concept with largest Extent and Intent containing both r_s and r_t
        largest_extent_concepts = [
            cpt for cpt in L_cov if {r_s, r_t}.issubset(cpt["Intent"])
        ]
        if largest_extent_concepts:
            max_extent_size = max(len(cpt["Extent"]) for cpt in largest_extent_concepts)
            Candidates = set()

            # Iterate through each concept in largest_extent_concepts
            for cpt in largest_extent_concepts:
                # Check if the length of the Extent is equal to max_extent_size
                if len(cpt["Extent"]) == max_extent_size:
                    # Iterate through each item in the Extent and add it as a tuple to Candidates
                    for item in cpt["Extent"]:
                        Candidates.add((item,))  # Add item as a tuple

    # Case 3: General case with intermediate regions (R_st has more than two regions)
    else:
        # Find the formal concept with the largest Extent and Intent containing all regions in R_st
        full_coverage_concepts = [
            cpt for cpt in L_cov if set(R_st).issubset(cpt["Intent"])
        ]
        
        if full_coverage_concepts:
            Candidates = set()
            for cpt in full_coverage_concepts:
                if len(cpt["Extent"]) > 1:
                    for item in cpt["Extent"]:
                       Candidates.add((item,))
        else:
            # If no single concept covers all regions, find multiple concepts whose Intents cover R_st
            partial_coverage_concepts = [
                cpt for cpt in L_cov if set(R_st).intersection(cpt["Intent"])
            ]
            # Generate all combinations of concepts to cover R_st by union of Intents            
            # Iterate over combination sizes from 2 to len(R_st)
            for size in range(2, len(R_st) + 1):
                for cpt_comb in itertools.combinations(partial_coverage_concepts, size):
                    combined_intent = set()
                    # Combine the intents of the selected concepts
                    for concept in cpt_comb:
                        combined_intent.update(concept["Intent"])

                    # Check if R_st is a subset of the combined intent
                    if set(R_st).issubset(combined_intent):
                        # Generate combinations of VaaS services from Extents of these concepts
                        Candidates.update(
                            {tuple(v) for v in product(*(entry["Extent"] for entry in cpt_comb))}
                        )
                        break  # Stop iterating once the condition is met

    return Candidates

def evaluate_vaas_candidates(R_st, candidates, problem):
    
    # Evaluate each candidate solution
    best_score = float('inf')
    for candidate in candidates:    
        # Transform candidate to a solution (array)
        solution= [-1 for _ in range(len(R_st))]
        i =0
        for r in R_st:
            for vid in candidate:
                if solution[i]==-1:
                    solution[i] =vid
            i+=1
        # Call eval function
        score= problem.obj_func(solution)
        # Update best solution if the current score is lower
        if score < best_score:
            best_score = score
            
    return score


"""# **Main program**"""

def run_ffca(vaas_list, R_st, problem):

    """sumary_line
        Keyword arguments:
        R_st: set of traversed regions 
        Return: return_description
    """
   #1. Create formal context 
   
    coverage_fc_dict = {}
    for  v in vaas_list:     
        reg={}
        for r in R_st:            
            reg.update({r: 1 if int(r) in v.covered_regions else 0})
        coverage_fc_dict.update({v.uid: reg})

    # Step 2: Generate formal concepts from the data
    L_cov = extract_formal_concepts(coverage_fc_dict)
    
    # Step 3: Display the formal concepts for each lattice    
    L_cov=reduce_lattice(L_cov)

    # Find candidate transportation solutions
    Candidates = find_candidates(R_st, L_cov)
    if not Candidates:
       return 9999 # Bad result
       
    result = evaluate_vaas_candidates( R_st, Candidates, problem)
    return result

"""# **For experiments**"""
if __name__ == '__main__':
    
    vaas_file = "./dataset/vaas/vaas_300.csv"
    regions_set = Region.create_regions(number_region=4, min_edges=2, min_nodes=20, max_edges=15, max_nodes=30)
    vaas = pd.read_csv(vaas_file)
    vaas_set =[]
    # Generate the set of Vass from the csv file
    for  index, v in vaas.iterrows():
        vs = VaaS(data=v)
        vaas_set.append(vs)
    user_query ={'source': 1,'destination':30, 'QoS':{'cost': 8, 'speed':100, 'availability':0.95, 'reputation': 0.8, 'place':2, 'rating':8}}
    c = local_paths(regions_set)
    regions_path = c.run(user_query["source"], user_query["destination"])      
    # Extract  regions to be our path:
    traversed_region = regions_path['regions']
    weights = [0.25, 0.25, 0.25, 0.25]

    R_st =[r.name for r in traversed_region]
    res = run_ffca(vaas_set, regions_set, R_st)
    print(res)

    #test_solution(vaas_file,regions_file, R_st)